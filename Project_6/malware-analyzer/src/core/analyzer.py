"""
Analizador principal que orquesta todos los motores
"""
from pathlib import Path
from typing import Dict, List, Optional
import time

from ..engines.virustotal_api import VirusTotalAPI
from ..core.hash_calculator import HashCalculator
from ..utils.keyring_manager import KeyringManager
from ..utils.logger import get_logger
from ..utils.config import LARGE_FILE_CONFIG, DETECTION_THRESHOLDS

logger = get_logger(__name__)


class MalwareAnalyzer:
    """Analizador principal que coordina todos los motores de análisis"""
    
    def __init__(self):
        """Inicializa el analizador con las API keys disponibles"""
        self.engines = {}
        self._initialize_engines()
    
    def _initialize_engines(self):
        """Inicializa los motores de análisis con las API keys disponibles"""
        keys = KeyringManager.get_all_keys()
        
        # VirusTotal
        if keys.get('virustotal'):
            try:
                self.engines['virustotal'] = VirusTotalAPI(keys['virustotal'])
                logger.info("Motor VirusTotal inicializado")
            except Exception as e:
                logger.error(f"Error inicializando VirusTotal: {e}")
        
        # TODO: Inicializar otros motores (Hybrid Analysis, MetaDefender, etc.)
        
        if not self.engines:
            logger.warning("No hay motores de análisis configurados. Configura al menos una API key.")
    
    def analyze_file(self, file_path: str, engines: Optional[List[str]] = None) -> Dict:
        """
        Analiza un archivo con los motores especificados
        
        Args:
            file_path: Ruta al archivo
            engines: Lista de motores a usar (None = todos disponibles)
            
        Returns:
            Dict con los resultados del análisis
        """
        file_path = Path(file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"Archivo no encontrado: {file_path}")
        
        logger.info(f"=== Iniciando análisis de {file_path.name} ===")
        
        start_time = time.time()
        file_size = file_path.stat().st_size
        
        # Calcular hashes
        logger.info("Calculando hashes...")
        hashes = HashCalculator.calculate_all_hashes(str(file_path))
        
        # Información básica del archivo
        file_info = {
            'name': file_path.name,
            'path': str(file_path),
            'size': file_size,
            'size_human': self._humanize_size(file_size),
            'md5': hashes['md5'],
            'sha1': hashes['sha1'],
            'sha256': hashes['sha256'],
        }
        
        # Decidir estrategia de análisis según tamaño
        if file_size > LARGE_FILE_CONFIG['max_supported_size']:
            logger.error(f"Archivo demasiado grande: {file_size} bytes. Máximo soportado: {LARGE_FILE_CONFIG['max_supported_size']}")
            return {
                'error': 'file_too_large',
                'file_info': file_info,
                'message': f"El archivo excede el tamaño máximo soportado de {self._humanize_size(LARGE_FILE_CONFIG['max_supported_size'])}"
            }
        
        # Seleccionar motores
        if engines is None:
            engines_to_use = list(self.engines.keys())
        else:
            engines_to_use = [e for e in engines if e in self.engines]
        
        if not engines_to_use:
            logger.error("No hay motores disponibles para el análisis")
            return {
                'error': 'no_engines_available',
                'file_info': file_info,
                'message': 'No hay motores de análisis configurados'
            }
        
        logger.info(f"Motores a usar: {', '.join(engines_to_use)}")
        
        # Ejecutar análisis con cada motor
        results = {}
        
        for engine_name in engines_to_use:
            logger.info(f"Analizando con {engine_name}...")
            
            try:
                engine = self.engines[engine_name]
                
                if engine_name == 'virustotal':
                    # Si el archivo es muy grande, consultar solo por hash
                    if file_size > LARGE_FILE_CONFIG['hash_only_threshold']:
                        logger.info("Archivo grande: consultando por hash en lugar de subir")
                        result = engine.get_file_report(hashes['sha256'])
                    else:
                        result = engine.scan_file(str(file_path))
                    
                    results[engine_name] = result
                
                # TODO: Añadir lógica para otros motores
                
            except Exception as e:
                logger.error(f"Error con motor {engine_name}: {e}")
                results[engine_name] = {
                    'error': str(e),
                    'status': 'failed'
                }
        
        # Calcular veredicto final
        final_verdict = self._calculate_final_verdict(results)
        
        elapsed_time = time.time() - start_time
        
        analysis_result = {
            'file_info': file_info,
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'analysis_time': round(elapsed_time, 2),
            'engines_used': engines_to_use,
            'results': results,
            'verdict': final_verdict['verdict'],
            'confidence': final_verdict['confidence'],
            'threat_level': final_verdict['threat_level'],
            'recommendations': final_verdict['recommendations'],
        }
        
        logger.info(f"=== Análisis completado en {elapsed_time:.2f}s ===")
        logger.info(f"Veredicto: {final_verdict['verdict']} (confianza: {final_verdict['confidence']}%)")
        
        return analysis_result
    
    def analyze_url(self, url: str, engines: Optional[List[str]] = None) -> Dict:
        """
        Analiza una URL
        
        Args:
            url: URL a analizar
            engines: Motores a usar
            
        Returns:
            Dict con los resultados
        """
        logger.info(f"=== Iniciando análisis de URL: {url} ===")
        
        start_time = time.time()
        
        # Seleccionar motores
        if engines is None:
            engines_to_use = list(self.engines.keys())
        else:
            engines_to_use = [e for e in engines if e in self.engines]
        
        results = {}
        
        for engine_name in engines_to_use:
            logger.info(f"Analizando URL con {engine_name}...")
            
            try:
                engine = self.engines[engine_name]
                
                if engine_name == 'virustotal':
                    result = engine.scan_url(url)
                    results[engine_name] = result
                
                # TODO: Otros motores
                
            except Exception as e:
                logger.error(f"Error con motor {engine_name}: {e}")
                results[engine_name] = {
                    'error': str(e),
                    'status': 'failed'
                }
        
        final_verdict = self._calculate_final_verdict(results)
        
        elapsed_time = time.time() - start_time
        
        return {
            'url': url,
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'analysis_time': round(elapsed_time, 2),
            'engines_used': engines_to_use,
            'results': results,
            'verdict': final_verdict['verdict'],
            'confidence': final_verdict['confidence'],
            'threat_level': final_verdict['threat_level'],
        }
    
    def analyze_hash(self, file_hash: str, engines: Optional[List[str]] = None) -> Dict:
        """
        Consulta un hash en las bases de datos sin subir archivo
        
        Args:
            file_hash: Hash MD5, SHA1 o SHA256
            engines: Motores a consultar
            
        Returns:
            Dict con los resultados
        """
        logger.info(f"=== Consultando hash: {file_hash} ===")
        
        if engines is None:
            engines_to_use = list(self.engines.keys())
        else:
            engines_to_use = [e for e in engines if e in self.engines]
        
        results = {}
        
        for engine_name in engines_to_use:
            logger.info(f"Consultando en {engine_name}...")
            
            try:
                engine = self.engines[engine_name]
                
                if engine_name == 'virustotal':
                    result = engine.get_file_report(file_hash)
                    results[engine_name] = result
                
                # TODO: Otros motores
                
            except Exception as e:
                logger.error(f"Error consultando en {engine_name}: {e}")
                results[engine_name] = {
                    'error': str(e),
                    'status': 'failed'
                }
        
        final_verdict = self._calculate_final_verdict(results)
        
        return {
            'hash': file_hash,
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'engines_used': engines_to_use,
            'results': results,
            'verdict': final_verdict['verdict'],
            'confidence': final_verdict['confidence'],
            'threat_level': final_verdict['threat_level'],
        }
    
    def _calculate_final_verdict(self, results: Dict) -> Dict:
        """
        Calcula un veredicto final basado en todos los motores
        
        Args:
            results: Dict con resultados de cada motor
            
        Returns:
            Dict con veredicto, confianza y recomendaciones
        """
        if not results:
            return {
                'verdict': 'DESCONOCIDO',
                'confidence': 0,
                'threat_level': 'unknown',
                'recommendations': ['No se pudo realizar el análisis']
            }
        
        total_malicious = 0
        total_checks = 0
        verdicts = []
        
        for engine_name, result in results.items():
            if result.get('error'):
                continue
            
            if engine_name == 'virustotal':
                if result.get('found'):
                    stats = result['analysis_stats']
                    total_malicious += stats['malicious'] + stats['suspicious']
                    total_checks += stats['total']
                    verdicts.append(result['verdict'])
            
            # TODO: Agregar lógica para otros motores
        
        if total_checks == 0:
            return {
                'verdict': 'DESCONOCIDO',
                'confidence': 0,
                'threat_level': 'unknown',
                'recommendations': ['No se obtuvieron resultados válidos']
            }
        
        detection_rate = (total_malicious / total_checks) * 100
        
        # Determinar veredicto
        if detection_rate >= DETECTION_THRESHOLDS['malicious']:
            verdict = 'MALICIOSO'
            threat_level = 'high'
            recommendations = [
                'NO ejecutar este archivo',
                'Eliminar inmediatamente',
                'Escanear el sistema con antivirus actualizado',
                'Cambiar contraseñas si fue ejecutado'
            ]
        elif detection_rate >= DETECTION_THRESHOLDS['likely_malicious']:
            verdict = 'PROBABLEMENTE MALICIOSO'
            threat_level = 'medium-high'
            recommendations = [
                'No ejecutar sin análisis adicional',
                'Consultar con expertos en seguridad',
                'Revisar en entorno aislado (sandbox)'
            ]
        elif detection_rate >= DETECTION_THRESHOLDS['suspicious']:
            verdict = 'SOSPECHOSO'
            threat_level = 'medium'
            recommendations = [
                'Proceder con precaución',
                'Ejecutar solo en entorno aislado',
                'Monitorear comportamiento del sistema'
            ]
        else:
            verdict = 'LIMPIO'
            threat_level = 'low'
            recommendations = [
                'Archivo parece seguro según los motores consultados',
                'Mantener antivirus actualizado',
                'Seguir buenas prácticas de seguridad'
            ]
        
        # Calcular confianza (basado en consenso)
        if len(set(verdicts)) == 1:
            confidence = 95  # Todos coinciden
        elif len(verdicts) >= 2:
            confidence = 75  # Mayoría coincide
        else:
            confidence = 50  # Solo un motor
        
        return {
            'verdict': verdict,
            'confidence': confidence,
            'threat_level': threat_level,
            'recommendations': recommendations,
            'detection_rate': round(detection_rate, 2),
        }
    
    @staticmethod
    def _humanize_size(size_bytes: int) -> str:
        """Convierte bytes a formato legible"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.2f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.2f} PB"
    
    def close(self):
        """Cierra todas las conexiones"""
        for engine in self.engines.values():
            if hasattr(engine, 'close'):
                engine.close()
        
        logger.info("Analizador cerrado")
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()
