"""
Cliente de VirusTotal API v3
Soporta archivos hasta 650MB con endpoint especial
"""
import time
import hashlib
import requests
from pathlib import Path
from typing import Dict, Optional, Tuple
import vt

from ..utils.config import (
    API_LIMITS, API_URLS, TIMEOUTS, USER_AGENT,
    LARGE_FILE_CONFIG
)
from ..utils.logger import get_logger

logger = get_logger(__name__)


class VirusTotalAPI:
    """Cliente para interactuar con VirusTotal API v3"""
    
    def __init__(self, api_key: str):
        """
        Inicializa el cliente de VirusTotal
        
        Args:
            api_key: API key de VirusTotal (obtener en https://www.virustotal.com/gui/my-apikey)
        """
        self.api_key = api_key
        self.client = vt.Client(api_key)
        self.session = requests.Session()
        self.session.headers.update({
            'x-apikey': api_key,
            'User-Agent': USER_AGENT
        })
        
        self.limits = API_LIMITS['virustotal']
        self.request_count = 0
        self.last_request_time = 0
        
        logger.info("Cliente VirusTotal inicializado")
    
    def _rate_limit(self):
        """Implementa rate limiting (4 requests/minuto)"""
        current_time = time.time()
        time_since_last = current_time - self.last_request_time
        
        min_interval = 60 / self.limits['requests_per_minute']
        
        if time_since_last < min_interval:
            sleep_time = min_interval - time_since_last
            logger.debug(f"Rate limit: esperando {sleep_time:.2f}s")
            time.sleep(sleep_time)
        
        self.last_request_time = time.time()
        self.request_count += 1
    
    def get_file_report(self, file_hash: str) -> Dict:
        """
        Obtiene el reporte de un archivo por su hash
        
        Args:
            file_hash: MD5, SHA1 o SHA256 del archivo
            
        Returns:
            Dict con el reporte del archivo
        """
        self._rate_limit()
        
        try:
            logger.info(f"Consultando reporte para hash: {file_hash}")
            file_obj = self.client.get_object(f"/files/{file_hash}")
            
            return self._parse_file_report(file_obj)
            
        except vt.APIError as e:
            if e.code == 'NotFoundError':
                logger.info(f"Hash no encontrado en VirusTotal: {file_hash}")
                return {'found': False, 'hash': file_hash}
            else:
                logger.error(f"Error API VirusTotal: {e}")
                raise
    
    def scan_file(self, file_path: str) -> Dict:
        """
        Sube y escanea un archivo
        
        Args:
            file_path: Ruta al archivo a escanear
            
        Returns:
            Dict con los resultados del análisis
        """
        file_path = Path(file_path)
        file_size = file_path.stat().st_size
        
        # Verificar tamaño
        if file_size > self.limits['max_file_size']:
            logger.warning(f"Archivo muy grande ({file_size} bytes). Máximo: {self.limits['max_file_size']}")
            # Calcular hash y consultar en su lugar
            file_hash = self._calculate_sha256(file_path)
            logger.info(f"Consultando por hash en lugar de subir: {file_hash}")
            return self.get_file_report(file_hash)
        
        # Decidir endpoint según tamaño
        if file_size > self.limits['large_file_endpoint_size']:
            return self._scan_large_file(file_path)
        else:
            return self._scan_normal_file(file_path)
    
    def _scan_normal_file(self, file_path: Path) -> Dict:
        """Escanea archivo <32MB usando endpoint normal"""
        self._rate_limit()
        
        logger.info(f"Escaneando archivo: {file_path.name} ({file_path.stat().st_size} bytes)")
        
        try:
            with open(file_path, 'rb') as f:
                analysis = self.client.scan_file(f)
            
            analysis_id = analysis.id
            logger.info(f"Archivo subido. Analysis ID: {analysis_id}")
            
            # Esperar resultados
            return self._wait_for_analysis(analysis_id)
            
        except Exception as e:
            logger.error(f"Error escaneando archivo: {e}")
            raise
    
    def _scan_large_file(self, file_path: Path) -> Dict:
        """Escanea archivo >32MB usando endpoint especial"""
        self._rate_limit()
        
        logger.info(f"Archivo grande detectado: {file_path.name} ({file_path.stat().st_size} bytes)")
        logger.info("Obteniendo URL de upload especial...")
        
        try:
            # Paso 1: Obtener URL de upload para archivos grandes
            response = self.session.get(
                f"{API_URLS['virustotal']}/files/upload_url",
                timeout=TIMEOUTS['api_request']
            )
            response.raise_for_status()
            upload_url = response.json()['data']
            
            logger.info(f"URL de upload obtenida: {upload_url}")
            
            # Paso 2: Subir archivo a la URL especial
            self._rate_limit()
            
            with open(file_path, 'rb') as f:
                files = {'file': (file_path.name, f)}
                response = self.session.post(
                    upload_url,
                    files=files,
                    timeout=TIMEOUTS['file_upload']
                )
                response.raise_for_status()
            
            analysis_id = response.json()['data']['id']
            logger.info(f"Archivo grande subido. Analysis ID: {analysis_id}")
            
            # Esperar resultados
            return self._wait_for_analysis(analysis_id)
            
        except Exception as e:
            logger.error(f"Error escaneando archivo grande: {e}")
            raise
    
    def _wait_for_analysis(self, analysis_id: str, max_wait: int = None) -> Dict:
        """
        Espera a que el análisis se complete
        
        Args:
            analysis_id: ID del análisis
            max_wait: Tiempo máximo de espera en segundos
            
        Returns:
            Dict con los resultados del análisis
        """
        if max_wait is None:
            max_wait = TIMEOUTS['analysis_wait']
        
        logger.info(f"Esperando resultados del análisis: {analysis_id}")
        
        start_time = time.time()
        
        while True:
            self._rate_limit()
            
            try:
                analysis = self.client.get_object(f"/analyses/{analysis_id}")
                
                if analysis.status == 'completed':
                    logger.info("Análisis completado")
                    # Obtener el reporte completo del archivo
                    file_id = analysis.meta['file_info']['sha256']
                    return self.get_file_report(file_id)
                
                elapsed = time.time() - start_time
                if elapsed > max_wait:
                    logger.warning(f"Timeout esperando análisis después de {elapsed:.0f}s")
                    return {
                        'status': 'timeout',
                        'analysis_id': analysis_id,
                        'message': 'Análisis en progreso, consulta más tarde'
                    }
                
                logger.debug(f"Análisis en progreso... ({elapsed:.0f}s)")
                time.sleep(15)  # Esperar 15 segundos antes de reintentar
                
            except Exception as e:
                logger.error(f"Error consultando estado del análisis: {e}")
                raise
    
    def scan_url(self, url: str) -> Dict:
        """
        Escanea una URL
        
        Args:
            url: URL a escanear
            
        Returns:
            Dict con los resultados del análisis
        """
        self._rate_limit()
        
        logger.info(f"Escaneando URL: {url}")
        
        try:
            analysis = self.client.scan_url(url)
            analysis_id = analysis.id
            
            logger.info(f"URL enviada para análisis. ID: {analysis_id}")
            
            # Esperar resultados
            return self._wait_for_analysis(analysis_id)
            
        except Exception as e:
            logger.error(f"Error escaneando URL: {e}")
            raise
    
    def get_ip_report(self, ip_address: str) -> Dict:
        """
        Obtiene el reporte de una dirección IP
        
        Args:
            ip_address: Dirección IP a consultar
            
        Returns:
            Dict con el reporte de la IP
        """
        self._rate_limit()
        
        logger.info(f"Consultando IP: {ip_address}")
        
        try:
            ip_obj = self.client.get_object(f"/ip_addresses/{ip_address}")
            return self._parse_ip_report(ip_obj)
            
        except vt.APIError as e:
            logger.error(f"Error consultando IP: {e}")
            raise
    
    def get_domain_report(self, domain: str) -> Dict:
        """
        Obtiene el reporte de un dominio
        
        Args:
            domain: Dominio a consultar
            
        Returns:
            Dict con el reporte del dominio
        """
        self._rate_limit()
        
        logger.info(f"Consultando dominio: {domain}")
        
        try:
            domain_obj = self.client.get_object(f"/domains/{domain}")
            return self._parse_domain_report(domain_obj)
            
        except vt.APIError as e:
            logger.error(f"Error consultando dominio: {e}")
            raise
    
    def _parse_file_report(self, file_obj) -> Dict:
        """Parsea el objeto de archivo de VirusTotal a un dict legible"""
        stats = file_obj.last_analysis_stats
        
        total_engines = sum(stats.values())
        malicious = stats.get('malicious', 0)
        suspicious = stats.get('suspicious', 0)
        undetected = stats.get('undetected', 0)
        
        detection_rate = ((malicious + suspicious) / total_engines * 100) if total_engines > 0 else 0
        
        # Determinar veredicto
        if malicious >= total_engines * 0.5:
            verdict = 'MALICIOSO'
        elif malicious + suspicious >= total_engines * 0.3:
            verdict = 'SOSPECHOSO'
        elif malicious + suspicious >= total_engines * 0.1:
            verdict = 'POTENCIALMENTE SOSPECHOSO'
        else:
            verdict = 'LIMPIO'
        
        # Obtener etiquetas de amenaza
        threat_labels = file_obj.popular_threat_classification.get('suggested_threat_label', 'Unknown')
        
        return {
            'found': True,
            'engine': 'VirusTotal',
            'file_info': {
                'md5': file_obj.md5,
                'sha1': file_obj.sha1,
                'sha256': file_obj.sha256,
                'size': file_obj.size,
                'type': file_obj.type_description,
                'magic': getattr(file_obj, 'magic', 'N/A'),
            },
            'analysis_stats': {
                'malicious': malicious,
                'suspicious': suspicious,
                'undetected': undetected,
                'harmless': stats.get('harmless', 0),
                'failure': stats.get('failure', 0),
                'total': total_engines,
            },
            'detection_rate': round(detection_rate, 2),
            'verdict': verdict,
            'threat_label': threat_labels,
            'first_submission_date': getattr(file_obj, 'first_submission_date', None),
            'last_analysis_date': file_obj.last_analysis_date,
            'times_submitted': getattr(file_obj, 'times_submitted', 0),
            'reputation': getattr(file_obj, 'reputation', 0),
            'vt_link': f"https://www.virustotal.com/gui/file/{file_obj.sha256}",
            'detailed_results': self._get_detailed_av_results(file_obj),
        }
    
    def _get_detailed_av_results(self, file_obj) -> Dict:
        """Extrae resultados detallados de cada motor AV"""
        results = {}
        
        for engine, result in file_obj.last_analysis_results.items():
            results[engine] = {
                'category': result['category'],
                'result': result['result'],
                'method': result.get('method', 'unknown'),
                'engine_version': result.get('engine_version', 'N/A'),
            }
        
        return results
    
    def _parse_ip_report(self, ip_obj) -> Dict:
        """Parsea el objeto de IP de VirusTotal"""
        stats = ip_obj.last_analysis_stats
        
        return {
            'engine': 'VirusTotal',
            'ip': ip_obj.id,
            'country': ip_obj.country,
            'as_owner': ip_obj.as_owner,
            'asn': ip_obj.asn,
            'analysis_stats': stats,
            'reputation': ip_obj.reputation,
            'vt_link': f"https://www.virustotal.com/gui/ip-address/{ip_obj.id}",
        }
    
    def _parse_domain_report(self, domain_obj) -> Dict:
        """Parsea el objeto de dominio de VirusTotal"""
        stats = domain_obj.last_analysis_stats
        
        return {
            'engine': 'VirusTotal',
            'domain': domain_obj.id,
            'categories': getattr(domain_obj, 'categories', {}),
            'analysis_stats': stats,
            'reputation': domain_obj.reputation,
            'popularity_ranks': getattr(domain_obj, 'popularity_ranks', {}),
            'vt_link': f"https://www.virustotal.com/gui/domain/{domain_obj.id}",
        }
    
    @staticmethod
    def _calculate_sha256(file_path: Path) -> str:
        """Calcula el SHA256 de un archivo"""
        sha256_hash = hashlib.sha256()
        
        with open(file_path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        
        return sha256_hash.hexdigest()
    
    def close(self):
        """Cierra la conexión con VirusTotal"""
        self.client.close()
        self.session.close()
        logger.info("Conexión con VirusTotal cerrada")
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()
